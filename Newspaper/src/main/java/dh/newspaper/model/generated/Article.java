package dh.newspaper.model.generated;

import java.util.List;
import dh.newspaper.model.generated.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table ARTICLE.
 */
public class Article {

    private Long id;
    /** Not-null value. */
    private String articleUrl;
    private String parentUrl;
    private String imageUrl;
    /** Not-null value. */
    private String title;
    private String author;
    /** Not-null value. */
    private String excerpt;
    private String content;
    private String language;
    /** Not-null value. */
    private java.util.Date published;
    private java.util.Date archived;
    private java.util.Date lastRead;
    private java.util.Date lastUpdated;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient ArticleDao myDao;

    private List<ArticleCategory> articleCategoryList;

    public Article() {
    }

    public Article(Long id) {
        this.id = id;
    }

    public Article(Long id, String articleUrl, String parentUrl, String imageUrl, String title, String author, String excerpt, String content, String language, java.util.Date published, java.util.Date archived, java.util.Date lastRead, java.util.Date lastUpdated) {
        this.id = id;
        this.articleUrl = articleUrl;
        this.parentUrl = parentUrl;
        this.imageUrl = imageUrl;
        this.title = title;
        this.author = author;
        this.excerpt = excerpt;
        this.content = content;
        this.language = language;
        this.published = published;
        this.archived = archived;
        this.lastRead = lastRead;
        this.lastUpdated = lastUpdated;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getArticleDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /** Not-null value. */
    public String getArticleUrl() {
        return articleUrl;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setArticleUrl(String articleUrl) {
        this.articleUrl = articleUrl;
    }

    public String getParentUrl() {
        return parentUrl;
    }

    public void setParentUrl(String parentUrl) {
        this.parentUrl = parentUrl;
    }

    public String getImageUrl() {
        return imageUrl;
    }

    public void setImageUrl(String imageUrl) {
        this.imageUrl = imageUrl;
    }

    /** Not-null value. */
    public String getTitle() {
        return title;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setTitle(String title) {
        this.title = title;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    /** Not-null value. */
    public String getExcerpt() {
        return excerpt;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setExcerpt(String excerpt) {
        this.excerpt = excerpt;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getLanguage() {
        return language;
    }

    public void setLanguage(String language) {
        this.language = language;
    }

    /** Not-null value. */
    public java.util.Date getPublished() {
        return published;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setPublished(java.util.Date published) {
        this.published = published;
    }

    public java.util.Date getArchived() {
        return archived;
    }

    public void setArchived(java.util.Date archived) {
        this.archived = archived;
    }

    public java.util.Date getLastRead() {
        return lastRead;
    }

    public void setLastRead(java.util.Date lastRead) {
        this.lastRead = lastRead;
    }

    public java.util.Date getLastUpdated() {
        return lastUpdated;
    }

    public void setLastUpdated(java.util.Date lastUpdated) {
        this.lastUpdated = lastUpdated;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<ArticleCategory> getArticleCategoryList() {
        if (articleCategoryList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ArticleCategoryDao targetDao = daoSession.getArticleCategoryDao();
            List<ArticleCategory> articleCategoryListNew = targetDao._queryArticle_ArticleCategoryList(id);
            synchronized (this) {
                if(articleCategoryList == null) {
                    articleCategoryList = articleCategoryListNew;
                }
            }
        }
        return articleCategoryList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetArticleCategoryList() {
        articleCategoryList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
